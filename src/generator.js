var fs = require('fs'),
	util = require('util'),
	info = require('../package.json'),
	async = require('async');

var supportedDialects = {
	mysql: 1,
	pg: 1
};

/**
 *
 * @param {Object} options
 * @param {String} options.dialect Either "mysql" or "pg"
 * @param {String} options.dsn The DSN to use to connect to the database
 * @param {String} options.schema The name of the schema/database to extract from
 * @param {String} [options.indent] String to use for indentation of generated code, defaults to "\t"
 * @param {String|Number} [options.outputFile] Filename to write to, or the number 1 to write to stdout
 * @param {Boolean} [options.camelize] Convert underscored names to camel case ("foo_bar" -> "fooBar")
 * @param {String} [options.eol] End-of-line character, defaults to "\n"
 * @param {String} [options.mode] The permission mode of the output file, defaults to 0644
 * @param {String} [options.encoding] The encoding of the output file, defaults to "utf8"
 * @param {String} [options.prepend] String to prepend to the beginning of the generated output
 * @param {String} [options.append] String to append to the end of the generated output
 * @param {String} [options.omitComments] Omit autogenerated comments
 * @param {function} [options.log] Logging function
 * @param {Function} [callback]
 */
module.exports = function(options, callback) {
	options = options || {};

	var requiredProperties = [ 'dialect', 'dsn', 'schema' ];
	for (var i = 0; i < requiredProperties.length; i++) {
		if (!options[requiredProperties[i]]) {
			callback && callback(new Error('options.' + requiredProperties[i] + ' is required'));
			return;
		}
	}

	options.dialect = options.dialect.toLowerCase();

	if (!supportedDialects[options.dialect]) {
		callback && callback(new Error('options.dialect must be either "mysql" or "pg"'));
		return;
	}

	options.eol = options.eol || '\n';
	options.encoding = options.encoding || 'utf8';
	options.mode = options.mode || 0644;
	options.indent = options.indent || '\t';

	function camelize(name) {
		return !options.camelize ? name : name.replace(/_(.)/g, function(all, c) {
			return c.toUpperCase();
		});
	}

	function runQuery(query, params, callback) {
		log('debug', 'QUERY: ' + query + ' :: ' + util.inspect(params));
		switch (options.dialect) {
			case 'mysql':
				client.query(query, params, callback);
				break;
			case 'pg':
				client.query(query, params, function(err, result) {
					callback(err, result && result.rows);
				});
				break;
		}
	}

	function write() {
		var string = [].slice.call(arguments, 0, -1)
				.map(function(obj) { return (obj || '').toString(); })
				.filter(function(message) { return !!message; })
				.join(options.eol) + options.eol,
			callback = arguments[arguments.length - 1],
			buffer = new Buffer(string, options.encoding);

		if (fd) {
			fs.write(fd, buffer, 0, buffer.length, null, function(err, written) {
				stats.bytesWritten += (written || 0);
				callback(err);
			});
		} else {
			stats.buffer += buffer.toString();
			stats.bytesWritten += buffer.length;
			process.nextTick(callback);
		}
	}

	function getListOfTables(callback) {
		var query = '';
		switch (options.dialect) {
			case 'mysql':
				query = 'SELECT\n' +
					'TABLE_NAME `name`\n' +
					'FROM information_schema.TABLES\n' +
					'WHERE TABLE_SCHEMA=?';
				break;
			case 'pg':
				query = 'SELECT\n' +
					'table_name "name"\n' +
					'FROM information_schema.tables\n' +
					'WHERE table_schema = \'public\'\n' +
					'AND table_catalog = $1';
				break;
		}

		runQuery(query, [ options.schema ], function(err, rows) {
			if (err) {
				callback(err);
				return;
			}

			callback(null, rows.map(function(row) {
				return row.name;
			}));
		});
	}

	function getListOfColumns(tableName, callback) {
		var query = '';
		switch (options.dialect) {
			case 'mysql':
				query = 'SELECT\n' +
					'COLUMN_NAME `name`\n' +
					'FROM information_schema.COLUMNS\n' +
					'WHERE TABLE_SCHEMA=?\n' +
					'AND TABLE_NAME=?\n' +
					'ORDER BY ORDINAL_POSITION ASC';
				break;
			case 'pg':
				query = 'SELECT\n' +
					'column_name "name" \n' +
					'FROM information_schema.columns\n' +
					'WHERE table_schema=\'public\'\n' +
					'AND table_catalog=$1\n' +
					'AND table_name=$2\n' +
					'ORDER BY ordinal_position ASC';
				break;
		}

		runQuery(query, [ options.schema, tableName ], function(err, results) {
			if (err) {
				callback(err);
				return;
			}

			callback(null, results.map(function(row) {
				return row.name;
			}));
		});
	}

	var log = options.log || function() {},
		fd = null,
		client = null,
		tableNames = null,
		stats = {
			start: new Date(),
			end: null,
			elapsed: null,
			written: 0,
			buffer: ''
		},
		db = require(options.dialect);

	function openFile(next) {
		if (typeof(options.outputFile) === 'string') {
			fs.open(options.outputFile, 'w', options.mode, function(err, descriptor) {
				if (!err) {
					fd = descriptor;
				}

				next(err);
			});
		} else {
			if (options.outputFile === 1) {
				fd = 1; //stdout
			}

			process.nextTick(next);
		}
	}

	function createClientAndConnect(next) {
		log('debug', 'Attempting connection with DSN "' + options.dsn + '"');
		var connect;
		switch (options.dialect) {
			case 'mysql':
				connect = function(callback) {
					client = db.createConnection(options.dsn);
					client.connect(callback);
				};
				break;
			case 'pg':
				connect = function(callback) {
					client = new db.Client(options.dsn);
					client.connect(callback);
				};
				break;
		}
		try {
			connect(next);
		} catch (e) {
			next('Error creating database client (check your DSN): ' + e);
		}
	}

	function writeHead(next) {
		log('info', 'Starting generation against schema "' + options.schema + '"');
		var functions = [];
		if (options.prepend) {
			functions.push(function(next) {
				write(options.prepend + options.eol, next);
			});
		}

		if (!options.omitComments) {
			functions.push(function(next) {
				var headerComment = '// autogenerated by ' + info.name +
					' v' + info.version + ' on ' + new Date();
				write(headerComment + options.eol, next);
			});
		}

		functions.push(function(next) {
			write('var sql = require(\'sql\');', options.eol, next);
		});

		async.series(functions, next);
	}

	function fetchTables(next) {
		getListOfTables(function(err, tables) {
			tableNames = tables;
			next(err);
		});
	}

	function processTables(next) {
		function writeTable(tableName, next) {
			var start = Date.now();
			log('info', 'Starting ' + options.schema + '.' + tableName + '...');
			getListOfColumns(tableName, function(err, columnNames) {
				if (err) {
					next(err);
					return;
				}

				log('debug', '  Found ' + columnNames.length + ' columns');

				var args = [];

				if (!options.omitComments) {
					args.push('/**');
					args.push(' * SQL definition for ' + options.schema + '.' + tableName);
					args.push(' */');
				}

				args.push('exports.' + camelize(tableName) + ' = sql.define({');
				args.push(options.indent + 'name: \'' + tableName + '\',');
				args.push(options.indent + 'columns: [');

				args.push(columnNames.map(function(columnName) {
					return options.indent + options.indent + '\'' + camelize(columnName) + '\'';
				}).join(',' + options.eol));

				args.push(options.indent + ']');
				args.push('});');
				args.push(options.eol);

				args.push(function(err) {
					if (!err) {
						log('debug', '  ...finished! (' + (Date.now() - start) + 'ms)');
					}

					next(err);
				});

				write.apply(null, args);
			});
		}

		async.eachSeries(tableNames, writeTable, next);
	}

	function writeTail(next) {
		if (options.append) {
			write(options.append, next);
		} else {
			process.nextTick(next);
		}
	}

	async.series([
		openFile,
		createClientAndConnect,
		writeHead,
		fetchTables,
		processTables,
		writeTail
	], function(appError) {
		if (appError) {
			log('error', appError);
		}

		stats.end = new Date();
		stats.elapsed = stats.end.getTime() - stats.start.getTime();
		if (fd && fd !== 1) {
			fs.close(fd, function(err) {
				if (err) {
					log('warn', 'Error closing file: ' + err);
				}

				log('info',
					'\nAll done! Wrote ' + stats.bytesWritten + ' bytes to ' +
						(options.outputFile || 'stdout') + ' in ' + stats.elapsed + 'ms',
					'yay!'
				);

				callback(appError, stats);
			});
		} else {
			callback(appError, stats);
		}
	});
};
